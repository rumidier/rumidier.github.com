<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perl | Meadows of wild horses]]></title>
  <link href="http://rumidier.github.com/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://rumidier.github.com/"/>
  <updated>2012-07-05T21:47:14+09:00</updated>
  <id>http://rumidier.github.com/</id>
  <author>
    <name><![CDATA[rumidier]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[catalyst]]></title>
    <link href="http://rumidier.github.com/blog/2012/07/04/catalyst/"/>
    <updated>2012-07-04T19:02:00+09:00</updated>
    <id>http://rumidier.github.com/blog/2012/07/04/catalyst</id>
    <content type="html"><![CDATA[<h2>DBIx::Class로 스키마 관리하기</h2>

<p><a href="http://advent.perl.kr/2011/2011-12-17.html">jeen</a>님이 발표한 스키마 관리 하기
입니다.</p>

<p>jeen님의 글을 보게 되면 기존의 스키마를 관리하는 방법은 sql의 잦은 교체시 많은 문제점이
발생하고 있다고 서술 합니다.</p>

<p>스키마 관리를 좀더 편하게 하기 위하여 마지막에 서술 하는
<a href="https://metacpan.org/module/dbicdump">dbicdump</a>를 사용하여 간편하게 스키마 관리를 해보도록
합니다.</p>

<p>dbicdump를 사용하기 위해 필요한 ResultBase.pm과 schema.pl파일을 만들어 보도록 하겠습니다.</p>

<h2>schema/schema.pl</h2>

<p><a href="http://rumidier.github.com/blog/2012/07/02/catalyst/">schema.pl 설명</a></p>

<p>[% codeblock schema.pl %]</p>

<pre><code>my $DB_NAME     = $ENV{DB}          || 'DB_NAME';
my $DB_USER     = $ENV{DB_USER}     || 'DB_USER';
my $DB_PASSWORD = $ENV{DB_PASSWORD} || 'DB_PASSWORD';

{
    schema_class =&gt; "Silex::Schema",
    connect_info =&gt; {
        dsn               =&gt; "dbi:mysql:$DB_NAME:127.0.0.1",
        user              =&gt; $DB_USER,
        pass              =&gt; $DB_PASSWORD,
        mysql_enable_utf8  =&gt; 1,
    },
    loader_options =&gt; {
        dump_directory     =&gt; 'lib',
        naming             =&gt; { ALL =&gt; 'v8' },
        skip_load_external =&gt; 1,
        relationships      =&gt; 1,
        use_moose          =&gt; 1,
        only_autoclean     =&gt; 1,
        col_collision_map  =&gt; 'column_%s',
        result_base_class =&gt; 'MyApp::Schema::ResultBase',
        overwrite_modifications =&gt; 1,
        datetime_undef_if_invalid =&gt; 1,
        custom_column_info =&gt; sub {
            my ($table, $col_name, $col_info) = @_;

            if ($col_name eq 'password') {
                return { %{ $col_info },
                         encode_column =&gt; 1,
                         encode_class  =&gt; 'Digest',
                         encode_args   =&gt; { algorithm =&gt; 'SHA-1', format =&gt; 'hex' },
                         encode_check_method =&gt; 'check_password' };
            } # DB password 설정
            if ($col_name eq 'created_on') {
                return { %{ $col_info }, set_on_create =&gt; 1, inflate_datetime =&gt; 1 };
            } # DB created_on 설정

            if ($col_name eq 'updated_on') {
                return { %{ $col_info }, set_on_create =&gt; 1, set_on_update =&gt; 1, inflate_datetime =&gt; 1 };
            } # DB updated_on 설정
        },
    },
}
</code></pre>

<p>[% endcodeblock %]</p>

<p>lib/MyApp/Schema/ResultBase.pm</p>

<p>ResultBase 클래스의 제약 문제 때문에 result_base_class 값을 지정해 줌으로써 모든 결과
 클래스들은 DBIx::Class::Core가 아닌 MyApp::Schema::ResultBase를 상속받게 합니다.
MyApp::Schema::ResultBase는 개인이 정의 해주는것 이므로 아래를 참조 합니다.</p>

<p>MD5 체크섬 값 아래에 중복되는 코드를 매번 적어주어야 했습니다.
이렇게 사용할 컴포넌트들을 결과클래스 별로 지정하는 대신 ResultBase 클래스를 읽어들입니다.
사실 이처럼 ResultBase를 놓고 여기에 컴포넌트를 일괄해서 읽어들이는 방식은
Cookbook 문서에서도 스타트업 속도 향상을 위해 권장하고 있습니다. - <a href="http://advent.perl.kr/2011/2011-12-17.html">by Jeen</a> -</p>

<p>그리고 컴포넌트의 사용을 위한 컬럼의 속성은 custom_column_info 속성에 코드를 등록해 지정할 수 있습니다.(schema.pl 하단 참조)
 위의 코드처럼 등록하면 created_on 속성에 TimeStamp 컴포넌트를 사용하기 위한 속성 값인 set_on_create 옵션이 모든 결과클래스에 추가됩니다.
(이거 멋지다..)</p>

<p>[% codeblock ResultBase.pm %]</p>

<pre><code>package MyApp::Schema::ResultBase;
use Moose;
use MooseX::NonMoose;
use namespace::autoclean;

extends 'DBIx::Class::Core';

__PACKAGE__-&gt;load_components(qw/
InflateColumn::DateTime
TimeStamp
/);

__PACKAGE__-&gt;meta-&gt;make_immutable;

1;
</code></pre>

<p>[% endcodeblock %]</p>

<p>위의 두가지 코드를 작성 하였다면 준비는 끝났습니다.
(<strong>dbicdump는 db 정보를 덤프해서 스키마를 작성</strong>하는 것으로 코드 작성및 작성 후에라도
db가 정의 되어 있어야 합니다.)</p>

<h2>dbicdump 사용하기</h2>

<p>아래를 실행한후 lib/MyApp/Schema/Result에 .pm 파일들이 새로 생성되거나 수정 되었다면 확인을 해보라</p>

<pre><code>$ dbicdump -Ilib schema/schema.pl
</code></pre>

<h2>MakeFile.pl 모듈 추가</h2>

<p>다른 모듈이 더 추가 될수 있습니다 에러 메세지를 확인 하고 필요한 모듈을 더 설치 하세요.</p>

<pre><code>requires "DBIx::Class::TimeStamp";
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Catalyst]]></title>
    <link href="http://rumidier.github.com/blog/2012/06/15/catalyst/"/>
    <updated>2012-06-15T17:56:00+09:00</updated>
    <id>http://rumidier.github.com/blog/2012/06/15/catalyst</id>
    <content type="html"><![CDATA[<h1>init catalyst project in silex</h1>

<p>카탈리스트 시작을 위해 Helper를 준비합니다.</p>

<pre><code>$ git clone git://github.com/aanoaa/Catalyst-Helper-View-TTSilex.git
...
$ git clone git://github.com/aanoaa/Catalyst-Helper-Carton.git
...
$ cd Catalyst-Helper-View-TTSilex/
$ git checkout develop
$ dzil build
...
$ cd Catalyst-Helper-View-TTSilex-v0.0.1/
$ perl Makefile.PL
...
$ make &amp;&amp; make install
...
$ cd ../../Catalyst-Helper-Carton/
$ dzil build
$ cd Catalyst-Helper-Carton-v0.0.1/
$ perl Makefile.PL
...
$ make &amp;&amp; make install
</code></pre>

<p>catalyst.pl을 사용 하여  Foo::Web을 생성합니다.</p>

<pre><code>$ cd ~/yourworkspace/
$ catalyst.pl Foo::Web
...
</code></pre>

<p>파일명을 수정하여 줍니다.</p>

<pre><code>$ cd Foo-Web/
$ mv foo_web.psgi app.psgi
</code></pre>

<p>스크립트를 사용하게 되면 .conf.new 파일이 생성이 되며 .conf파일에 붙여줍니다.</p>

<pre><code>$ script/foo_web_create.pl view Bootstrap TTSilex
...
$ vi foo_web.conf &lt;&lt;--- foo_web.conf.new
</code></pre>

<p>카툰을 설치 하고 Make 파일에 추가 하라는 메세지가 나옵니다.</p>

<pre><code>$ script/foo_web_create.pl Carton
...
$ vim Makefile.PL    # add dependencies
</code></pre>

<p>위의 단계에서 명시된 모듈 및 추가 필요 모듈</p>

<pre><code>//명시
requires "Starman";
requires "Devel::Cover";
requires "Perl::Metrics::Lite";
requires "TAP::Formatter::JUnit";

//추가
requires 'Catalyst::Plugin::Unicode::Encoding';
requires "Catalyst::View::TT";
</code></pre>

<p>한글 인코딩 문제</p>

<pre><code>$ lib/Foo/Web.pm

use utf8;
use Catalyst qw/
-Debug
ConfigLoader
Static::Simple
#추가
Unicode::Encoding
/;
</code></pre>

<p>인스톨</p>

<pre><code>$ carton install
...
</code></pre>

<p>부분 인스톨</p>

<pre><code>$ carton install &lt;모듈네임&gt; 합니다.
</code></pre>

<h2>Controller 생성</h2>

<pre><code>$ script/foo_web_create.pl controller List

$ cd lib/Foo/Web/Controller
$ vi List.pm
// 주석처리
# $c-&gt;response-&gt;body('Matched Foo::Web::Controller::List in List.');
</code></pre>

<h2>View 생성</h2>

<pre><code>$ mkdir root/templates/bootstap/src/list
$ cd root/templates/bootstrap/src/list
$ vi index.tt
  &lt;p&gt;나는 지금 한글을 테스트 중입니다.&lt;/p&gt; 작성
</code></pre>

<h2>실행</h2>

<pre><code>$ ./run
</code></pre>

<h2>.gitignore</h2>

<pre><code># inspire by github/gitignore
blib/
.build/
_build/
cover_db/
inc/
Build
Build.bat
.last_cover_stats
Makefile
Makefile.old
MANIFEST.bak
META.yml
MYMETA.yml
nytprof.out
pm_to_blib
# custom
local/
.sass-cache/
tt_cache/
.carton/
*.log
session
MYMETA.json
carton.lock
</code></pre>

<h2>script/bootstrap.pl</h2>

<p>이건 헬퍼 없습니다.
프로젝트마다 손으로 복사합니다.</p>

<p>https://gist.github.com/2761721</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl]]></title>
    <link href="http://rumidier.github.com/blog/2012/05/25/perl/"/>
    <updated>2012-05-25T17:28:00+09:00</updated>
    <id>http://rumidier.github.com/blog/2012/05/25/perl</id>
    <content type="html"><![CDATA[<h3>목록으로 부터 중복된 값 제거</h3>

<h3>해결 방안</h3>

<p>hash를 이용하여 목록에 존재하는 각 값을 한번만 저장하고, keys 함수를
이용하여 이를 활용하면 된다. 이때, 프로그래머는 코드를 보다 짧고 빠르게
해주는 펄의 다양한 아이디어를 적용할 수 있다.</p>

<h2>일반적인 방법</h2>

<p>해쉬값을 체크하고 값이 존재 하지 않는다면 배열을 생성한다.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>uniq값 구하기 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my %seen = ();
</span><span class='line'>my @uniq = ();
</span><span class='line'>foreach my $item (@list) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>unless ($seen{$item}) {
</span><span class='line'>    # 한번도 나타 나지 않은 값에 대해서만 처리
</span><span class='line'>$seen{$item} = 1;
</span><span class='line'>push(@uniq, $item);
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>좀더 빠른 처리 방법 - 01</h2>

<p>이전에 나타내는 값이 없는 값을 처리할 경우 이를 해쉬에 저장 하게 된다 (++연산자는 카운팅 기능)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>uniq값 구하기 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my %seen = ();
</span><span class='line'>my @uniq = ();
</span><span class='line'>foreach my $item (@list) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>push @uniq, $item unless $seen{$item}++;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>좀더 빠른 처리 방법 - 02</h2>

<p>해쉬에 저장 하고 그 키값 만은 추출 한다. (순서가 뒤죽박죽이다)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>uniq값 구하기 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my %seen = ();
</span><span class='line'>foreach my $item (@list) {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>$seen{$item}++;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}
</span><span class='line'>my @uniq = keys %seen;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>좀더 빠른 처리 방법 - 03</h2>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>uniq값 구하기 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my %seen = ();
</span><span class='line'>my @uniq = grep { ! $seen{$_}++ } @list;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>exam-code</h2>

<p>https://gist.github.com/2786790</p>
]]></content>
  </entry>
  
</feed>
